import { DocumentNode, IntrospectionQuery, GraphQLSchema } from 'graphql';
import { Cache, FieldInfo, ResolverConfig, DataField, Variables, Data, QueryInput, UpdatesConfig, OptimisticMutationConfig, KeyingConfig, DataFields } from '../types';
import * as InMemoryData from './data';
declare type RootField = 'query' | 'mutation' | 'subscription';
export interface StoreOpts {
    updates?: Partial<UpdatesConfig>;
    resolvers?: ResolverConfig;
    optimistic?: OptimisticMutationConfig;
    keys?: KeyingConfig;
    schema?: IntrospectionQuery;
}
export declare class Store implements Cache {
    data: InMemoryData.InMemoryData;
    resolvers: ResolverConfig;
    updates: UpdatesConfig;
    optimisticMutations: OptimisticMutationConfig;
    keys: KeyingConfig;
    schema?: GraphQLSchema;
    rootFields: {
        query: string;
        mutation: string;
        subscription: string;
    };
    rootNames: {
        [name: string]: RootField;
    };
    constructor(opts?: StoreOpts);
    keyOfField: (fieldName: string, args?: Variables | null | undefined) => string;
    keyOfEntity(data: Data): string | null;
    resolveFieldByKey(entity: Data | string | null, fieldKey: string): DataField;
    resolve(entity: Data | string | null, field: string, args?: Variables): DataField;
    invalidate(entity: Data | string, field?: string, args?: Variables): void;
    inspectFields(entity: Data | string | null): FieldInfo[];
    updateQuery(input: QueryInput, updater: (data: Data | null) => DataFields | null): void;
    readQuery(input: QueryInput): Data | null;
    readFragment(dataFragment: DocumentNode, entity: string | Data, variables?: Variables): Data | null;
    writeFragment(dataFragment: DocumentNode, data: Data, variables?: Variables): void;
}
export {};
