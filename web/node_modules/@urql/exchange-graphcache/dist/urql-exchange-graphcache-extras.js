"use strict";

var _rollupPluginBabelHelpers = require("./7832a774.js"), core = require("@urql/core"), defaultPageInfo = {
  __typename: "PageInfo",
  endCursor: null,
  startCursor: null,
  hasNextPage: !1,
  hasPreviousPage: !1
}, ensureKey = function(a) {
  return "string" == typeof a ? a : null;
}, concatEdges = function(a, g, d) {
  var c, b, f, l, m;
  for (c = new Set, b = 0, f = g.length; b < f; b++) {
    "string" == typeof (l = a.resolve(g[b], "node")) && c.add(l);
  }
  g = g.slice();
  b = 0;
  for (f = d.length; b < f; b++) {
    "string" != typeof (m = a.resolve(l = d[b], "node")) || c.has(m) || (c.add(m), g.push(l));
  }
  return g;
}, compareArgs = function(a, g) {
  var d, c, b, f;
  for (d in g) {
    if ("first" !== d && "last" !== d && "after" !== d && "before" !== d) {
      if (!(d in a)) {
        return !1;
      }
      if (typeof (c = a[d]) != typeof (b = g[d]) || "object" != typeof c ? c !== b : core.stringifyVariables(c) !== core.stringifyVariables(b)) {
        return !1;
      }
    }
  }
  for (f in a) {
    if ("first" !== f && "last" !== f && "after" !== f && "before" !== f && !(f in g)) {
      return !1;
    }
  }
  return !0;
}, getPage = function(a, g, d) {
  var b, f, l, m, c = ensureKey(a.resolveFieldByKey(g, d));
  if (!c) {
    return null;
  }
  g = a.resolve(c, "__typename");
  d = a.resolve(c, "edges") || [];
  if ("string" != typeof g) {
    return null;
  }
  g = {
    __typename: g,
    edges: d,
    pageInfo: defaultPageInfo
  };
  if ("string" == typeof (b = a.resolve(c, "pageInfo"))) {
    c = ensureKey(a.resolve(b, "__typename"));
    f = ensureKey(a.resolve(b, "endCursor")), l = ensureKey(a.resolve(b, "startCursor")), 
    m = a.resolve(b, "hasNextPage");
    b = a.resolve(b, "hasPreviousPage");
    null === (c = g.pageInfo = {
      __typename: "string" == typeof c ? c : "PageInfo",
      hasNextPage: "boolean" == typeof m ? m : !!f,
      hasPreviousPage: "boolean" == typeof b ? b : !!l,
      endCursor: f,
      startCursor: l
    }).endCursor && (f = d[d.length - 1]) && (f = a.resolve(f, "cursor"), c.endCursor = ensureKey(f));
    null === c.startCursor && (d = d[0]) && (a = a.resolve(d, "cursor"), c.startCursor = ensureKey(a));
  }
  return g;
};

exports.relayPagination = function(a) {
  void 0 === a && (a = {});
  var g = a.mergeMode || "inwards";
  return function(a, c, b, f) {
    var d, m, u, q, r, p, h, n, k, e;
    d = f.fieldName;
    if (0 !== (u = (m = b.inspectFields(a = f.parentKey).filter((function(b) {
      return b.fieldName === d;
    }))).length)) {
      for (q = null, r = [], p = [], h = _rollupPluginBabelHelpers._extends({}, defaultPageInfo), 
      n = 0; n < u; n++) {
        e = (k = m[n]).fieldKey;
        null !== (k = k.arguments) && compareArgs(c, k) && (null !== (e = getPage(b, a, e)) && ("inwards" === g && "number" == typeof k.last && "number" == typeof k.first ? (h = e.edges.slice(0, k.first + 1), 
        k = e.edges.slice(-k.last), r = concatEdges(b, r, h), p = concatEdges(b, k, p), 
        h = e.pageInfo) : k.after ? (r = concatEdges(b, r, e.edges), h.endCursor = e.pageInfo.endCursor, 
        h.hasNextPage = e.pageInfo.hasNextPage) : k.before ? (p = concatEdges(b, e.edges, p), 
        h.startCursor = e.pageInfo.startCursor, h.hasPreviousPage = e.pageInfo.hasPreviousPage) : ("number" == typeof k.last ? p = concatEdges(b, p, e.edges) : r = concatEdges(b, r, e.edges), 
        h = e.pageInfo), e.pageInfo.__typename !== h.__typename && (h.__typename = e.pageInfo.__typename), 
        q !== e.__typename && (q = e.__typename)));
      }
      if ("string" == typeof q) {
        if (!ensureKey(b.resolve(a, d, c))) {
          if (f.store.schema) {
            f.partial = !0;
          } else {
            return;
          }
        }
        return {
          __typename: q,
          edges: "inwards" === g ? concatEdges(b, r, p) : concatEdges(b, p, r),
          pageInfo: {
            __typename: h.__typename,
            endCursor: h.endCursor,
            startCursor: h.startCursor,
            hasNextPage: h.hasNextPage,
            hasPreviousPage: h.hasPreviousPage
          }
        };
      }
    }
  };
};

exports.simplePagination = function(a) {
  var g, d, c;
  void 0 === a && (a = {});
  void 0 === (g = a.offsetArgument) && (g = "skip");
  void 0 === (d = a.limitArgument) && (d = "limit");
  c = function(b, a) {
    var c, f, u, q;
    for (c in a) {
      if (c !== g && c !== d) {
        if (!(c in b)) {
          return !1;
        }
        if (typeof (f = b[c]) != typeof (u = a[c]) || "object" != typeof f ? f !== u : core.stringifyVariables(f) !== core.stringifyVariables(u)) {
          return !1;
        }
      }
    }
    for (q in b) {
      if (q !== g && q !== d && !(q in a)) {
        return !1;
      }
    }
    return !0;
  };
  return function(b, a, d, m) {
    var f, q, r, p, h, n, k, e, l, t, v;
    f = m.fieldName;
    if (0 !== (r = (q = d.inspectFields(b = m.parentKey).filter((function(a) {
      return a.fieldName === f;
    }))).length)) {
      for (p = new Set, h = [], n = null, k = 0; k < r; k++) {
        l = (e = q[k]).fieldKey;
        if (null !== (e = e.arguments) && c(a, e) && (l = d.resolveFieldByKey(b, l), e = e[g], 
        null !== l && 0 !== l.length && "number" == typeof e)) {
          if (!n || e > n) {
            for (n = 0; n < l.length; n++) {
              p.has(t = l[n]) || (h.push(t), p.add(t));
            }
          } else {
            n = [];
            for (t = 0; t < l.length; t++) {
              p.has(v = l[t]) || (n.push(v), p.add(v));
            }
            h = n.concat(h);
          }
          n = e;
        }
      }
      if (d.resolve(b, f, a)) {
        return h;
      }
      if (m.store.schema) {
        return m.partial = !0, h;
      }
    }
  };
};
//# sourceMappingURL=urql-exchange-graphcache-extras.js.map
